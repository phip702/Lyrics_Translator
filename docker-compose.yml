version: '3.8'

services:
  rabbitmq:
    hostname: rabbitmq
    image: rabbitmq:3.9-management
    ports:
      - "5672:5672"   # RabbitMQ default port
      - "15672:15672"  # RabbitMQ management UI port
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
      TZ: "America/Denver"
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 10s
      retries: 3
      start_period: 30s
      timeout: 5s

  flask-app:
    build:
      context: . #Tells it to use the current directory's files
      dockerfile: Dockerfile
    ports:
      - "5001:5000"
    environment:
      - FLASK_APP=app #uses the app folder (defaults to __init__.py)
      - FLASK_ENV=development
      - FLASK_RUN_HOST=0.0.0.0
      - RABBITMQ_HOST=rabbitmq
      # - CELERY_BROKER_URL=pyamqp://guest@rabbitmq//  # This is where Celery connects to RabbitMQ
      # - CELERY_RESULT_BACKEND=rpc://  # Celery backend to track results
    volumes:
      - .:/app  # Mount the current directory to /app inside the container; meaning changes to local files go to container's files as well
      - ./app/db.sqlite3:/app/db.sqlite3 # Mount the local SQLite DB into the container
    depends_on:
      - rabbitmq # Ensures rabbitmq starts before flask-app
    # CMD to wait for RabbitMQ to be ready, then run Flask
    command: ["/wait-for-it.sh", "rabbitmq:5672", "--", "flask", "run", "--host=0.0.0.0", "--port=5000"]

  # db:
  #   image: postgres
  #   environment: 
  #     POSTGRES_USER: user
  #     POSTGRES_PASSWORD: secret
  #     POSTGRES_DB: mypostgres #name of the db
  #   ports:
  #     - "5432:5432"

  # adminer: 
  #   image: adminer
  #   ports:
  #     - "5001:8080" #map local port 5001 to container's 8080


    
